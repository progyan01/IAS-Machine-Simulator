MEM_SIZE = 1000    
AC = 0             #Accumulator to store result of arithmetic or load
MQ = 0             #Helper register for multiply/divide operation
MBR = 0            #Holds the current 40 bit instruction
MAR = 0            #Holds the current instruction's 12 bit memory address
IR = 0             #Holds the current instruction's 8 bit OP Code
IBR = None         #Holds the right instruction (20 bits)
PC = 0             #Holds the memory address of next instruction
MEMORY = ['0' * 40] * MEM_SIZE
#Memory(RAM): list of 1000 string, each of 40 character(0 or 1)

#Helper functions to safely convert python 'numbers' to bits and vice versa
def to_signed(val):
    if val & (1 << 39):
        return val - (1 << 40)
    return val
def to_unsigned(val):
    return val & 0xFFFFFFFFFF

def fetch_decode():
    global PC, MAR, MBR, IR, IBR
    
    #If IBR is empty, fetch new word from Memory
    if IBR is None:
        MAR = PC
        MBR = int(MEMORY[MAR], 2)
        
        #Left Instruction (Bits 0-19); Opcode: 0-7, Address: 8-19
        left_part = (MBR >> 20) & 0xFFFFF
        IR = (left_part >> 12) & 0xFF
        MAR = left_part & 0xFFF
        
        #Sves the right Instruction (bits 20-39) to IBR
        IBR = MBR & 0xFFFFF
    else:
        #Execute instruction in IBR
        right_part = IBR
        IR = (right_part >> 12) & 0xFF
        MAR = right_part & 0xFFF
        IBR = None
        PC += 1               #Increment PC after right instruction

def execute():
    global AC, MQ, MBR, MAR, IR, MEMORY, PC, IBR

    #Fetch Data for Arithmetic Ops
    if IR in [1, 5, 6, 11, 12]: 
        MBR = to_signed(int(MEMORY[MAR], 2))

    if IR == 0:            #NOP
        pass
    elif IR == 1:          #LOAD M(X)
        AC = MBR
    elif IR == 5:          #ADD M(X)
        AC += MBR
    elif IR == 6:          #SUB M(X)
        AC -= MBR

    elif IR == 11:         #MUL M(X) (Upper 39 bits to AC, Lower 39 to MQ)
        res = AC * MBR
        AC = res  
        MQ = 0 
    elif IR == 12:         #DIV M(X) (Quotient -> MQ, Remainder -> AC)
        if MBR != 0:
            MQ = AC // MBR
            AC = AC % MBR
        else:
            print("Error: Division by Zero")

    elif IR == 20:         #LSH (Left Shift)
        AC = AC << 1
    elif IR == 21:         #RSH (Right Shift)
        AC = AC >> 1

    elif IR == 33:         #STOR M(X)
        MEMORY[MAR] = format(to_unsigned(AC), '040b')
    elif IR == 18:         #STOR_L M(X, 8:19)
        current_word = int(MEMORY[MAR], 2)      #This is the "Self-Modifying" instruction
        
        #Instruction structure: Left Op(8 bits) | Left Addr(12 bits) || Right Op(8 bits) | Right Addr(12 bits)
        #We replace Bits 8-19 (The Left Address) with AC's lower 12 bits
        
        left_op = (current_word >> 32) & 0xFF
        right_part = current_word & 0xFFFFF
        new_addr = AC & 0xFFF
        
        new_word = (left_op << 32) | (new_addr << 20) | right_part
        MEMORY[MAR] = format(new_word, '040b')

    elif IR == 13:         #JUMP M(X, 0:19)
        PC = MAR
        IBR = None         #Clear IBR to force fetch from new PC
    elif IR == 15:         #JUMP+ M(X, 0:19)
        if AC >= 0:
            PC = MAR
            IBR = None

    elif IR == 255:        #HALT
        print("\nHALT ENCOUNTERED")
        return False

    return True

#loads the binary file generated by assembler.py
def load_binary(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
        for i, line in enumerate(lines):
            if i < MEM_SIZE:
                MEMORY[i] = line.strip()

#prints the status of each variable at every cycle
def print_trace(cycle):
    print(f"Cycle {cycle:<3} | PC: {PC:<3} | IR: {IR:<3} | MAR: {MAR:<4} | AC: {AC:<5} | MQ: {MQ:<5} | IBR: {'YES' if IBR else 'NO'}")

if __name__ == "__main__":
    load_binary("binary.txt")
    print(f"{'Cycle':<9} | {'PC':<7} | {'IR':<7} | {'MAR':<8} | {'AC':<9} | {'MQ':<9} | {'IBR'}")
    print("-" * 70)
    
    cycle = 0
    running = True
    
    while running:
        cycle += 1
        fetch_decode()
        running = execute()
        print_trace(cycle)
        
        #Safety Break
        if cycle > 500:
            print("Terminating: Max cycles reached.")
            break

    #Dump Final Memory for Verification
    print(f"\nFinal Result (ANS at 104): {int(MEMORY[104], 2)}")
